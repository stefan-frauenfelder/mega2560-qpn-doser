/*****************************************************************************
* Model: mega2560-qpn-doser.qm
* File:  ./mega2560-qpn-doser.ino
*
* This code has been generated by QM tool (see state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*****************************************************************************/
/*${.::mega2560-qpn-doser.ino} .............................................*/

//#include "includes.h"

//#include "qfn_port.h"               // QP-nano port
#include "qpn.h"                    // QP-nano port
#include "board.h"                  // Board Support Functions
#include "activeObjects.h"          // application interface


Q_DEFINE_THIS_FILE

 // this blathering on is in case you want to make the class a static variable in a function
extern "C" {
  __extension__ typedef int __guard __attribute__((mode (__DI__)));
  int __cxa_guard_acquire(__guard *g) { return !*(char *)(g); };
  void __cxa_guard_release (__guard *g) { *(char *)g = 1; };
  void __cxa_guard_abort (__guard *) { };
} // end extern "C"



static QEvt scaleQueue[5];
static QEvt grinderQueue[5];
static QEvt encoderQueue[5];

// QF_active[] array defines all active object control blocks
QActiveCB const Q_ROM Q_ROM_VAR QF_active[] = {
    { (QActive *)0,           (QEvt *)0,     0                    },
    { (QActive *)&AO_Scale,   scaleQueue,    Q_DIM(scaleQueue)    },
    { (QActive *)&AO_Grinder, grinderQueue,  Q_DIM(grinderQueue)  },
    { (QActive *)&AO_Encoder, encoderQueue,  Q_DIM(encoderQueue)  }
};


// make sure that the QF_active[] array matches QF_MAX_ACTIVE in qpn_port.h
Q_ASSERT_COMPILE(QF_MAX_ACTIVE == Q_DIM(QF_active) - 1);

//Q_ASSERT_COMPILE(1 - 1);

/*${components::TargetDose} ................................................*/
float TargetDose;

/*${components::Weight} ....................................................*/
float Weight;



/* QF callbacks ============================================================*/
void QF_onStartup(void) {
    BSP_setupTickTimer();
}
/*..........................................................................*/
void QF_onCleanup(void) {
}

/*..........................................................................*/
void QV_onIdle(void) {   /* called with interrupts DISABLED, see NOTE1 */
    QF_INT_ENABLE(); /* just enable interrupts */
}
/*..........................................................................*/
void Q_onAssert(char const Q_ROM * const file, int line) {
    /* implement the error-handling policy for your application!!! */
    Serial1.println("Q_onAssert.");
    QF_INT_DISABLE(); /* disable all interrupts */
    QF_RESET();  /* reset the CPU */
}

void setup() {

    /*
    BSP_init(); // initialize the BSP

    QF::init(); // initialize the framework and the underlying RT kernel

    static QEvt const *grinder_queueSto[10]; // alocate event queue buffer
    static QEvt const *scale_queueSto[10]; // alocate event queue buffer

    static QF_MPOOL_EL(GrinderEvent) l_smlPoolSto[20]; //storage for small epool

    QF::poolInit(l_smlPoolSto, sizeof(l_smlPoolSto), sizeof(l_smlPoolSto[0])); // initialize event pools...

    DOSE = 7.0;

    AO_Grinder->start(1, grinder_queueSto, Q_DIM(grinder_queueSto), (void *)0, 0U); // start the grinder active object
    AO_Scale->start(2, scale_queueSto, Q_DIM(scale_queueSto), (void *)0, 0U);        // start the scale active object
    */

    BSP_init(); // initialize the BSP

    aoScale_constructor();
    aoGrinder_constructor();
    aoEncoder_constructor();

    QF_run();       // transfer control to QF-nano
}

void loop() {

}
